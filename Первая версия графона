#include <SFML/Graphics.hpp>
#include <iostream>
#include <math.h>
using namespace sf;
using namespace std;
struct planet
{
	int x,y,ships,state,belong,type;
};
void begining(struct planet *planets)
{   
	///первая///
	planets[0].state=0;
	planets[0].ships=5;
	planets[0].x=100;
	planets[0].y=400;
	planets[0].belong=1;// Пренадлежность к игроку(1-синий,2-красный,0-свободна)
	planets[0].type=1;//Один из трех типов планет(различия только визульные)
	///вторая///
	planets[1].state=0;
	planets[1].ships=0;
	planets[1].x=700;
	planets[1].y=100;
	planets[1].belong=2;
	planets[1].type=2;
	///третья///
	planets[2].state=0;
	planets[2].ships=0;
	planets[2].x=1000;
	planets[2].y=450;
	planets[2].belong=3;
	planets[2].type=3;
	///четвертая///
	planets[3].state=0;
	planets[3].ships=0;
	planets[3].x=300;
	planets[3].y=50;
	planets[3].belong=0;
	planets[3].type=1;
}
void add_planets(struct planet  *planets, float *timescore, int N)
{
	float time=*timescore;
	RenderWindow window(VideoMode(1280,720),"1.0"); 

	Image fn; //создаем объект Image (изображение)
	fn.loadFromFile("images\\fn.jpg");//загружаем в него файл

	Texture fn_texture;//создаем объект Texture (текстура)
	fn_texture.loadFromImage(fn);//передаем в него объект Image (изображения)

	Sprite fn_sprite;//создаем объект Sprite(спрайт)
	fn_sprite.setTexture(fn_texture);//передаём в него объект Texture (текстуры)
	fn_sprite.setPosition(0, 0);//задаем начальные координаты появления спрайта

	Image _planets; 
	_planets.loadFromFile("images\\planets.jpg");
	_planets.createMaskFromColor(Color(0, 0, 0));

	Texture planets_texture;
	planets_texture.loadFromImage(_planets);

	Sprite planets1_sprite[4];
	Sprite planets2_sprite[4];

	for(int i=0 ; i < N ; i++)
	{
		planets1_sprite[i].setTexture(planets_texture);
		planets1_sprite[i].setPosition(planets[i].x, planets[i].y);
		planets2_sprite[i].setTexture(planets_texture);
		planets2_sprite[i].setPosition(planets[i].x, planets[i].y);
		int y1 = (planets[i].type-1)*200, y2=y1+600;
		planets1_sprite[i].setTextureRect(IntRect(0,y1,200,200));
		planets2_sprite[i].setTextureRect(IntRect(0,y2,200,200));
		if(planets[i].belong==1)
		{
			planets1_sprite[i].setColor(Color::Cyan);
			planets2_sprite[i].setColor(Color::Cyan);
		}
		if(planets[i].belong==2)
		{
			planets1_sprite[i].setColor(Color::Green);
			planets2_sprite[i].setColor(Color::Green);
		}
		if(planets[i].belong==3)
		{
			planets1_sprite[i].setColor(Color::Red);
			planets2_sprite[i].setColor(Color::Red);
		}
	}

	Clock clock;
	while (window.isOpen())
	{
		float time0 = clock.getElapsedTime().asMicroseconds(); //дать прошедшее время в микросекундах
		clock.restart(); //перезагружает время
		time0 = time0/1000; //скорость игры
		Event event;
		while (window.pollEvent(event))
		{
			if (event.type == sf::Event::Closed)
				window.close();
		}
		int k=4,A=150;
		time=time+time0;
		*timescore=time;
		for(int j=0;j<k;j++)
		{
            if(time > A*j)  
			for (int i=0 ; i < N ; i++)
			{
				int y1 = (planets[i].type-1)*200, y2=y1+600,x=j*200;
				planets1_sprite[i].setTextureRect(IntRect(x,y1,200,200));
				planets2_sprite[i].setTextureRect(IntRect(x,y2,200,200));
				if((time > A*k)&&(i==N-1))
					time=0;
			}
		}
		if (event.type == Event::MouseButtonPressed)
			if (event.key.code == Mouse::Left)
				for (int i=0 ; i < N ; i++)
					if (event.mouseButton.x > planets[i].x && event.mouseButton.x < (planets[i].x + 200) && event.mouseButton.y > planets[i].y && event.mouseButton.y < (planets[i].y + 200) )
					{
                    for(int j=0; j < N;j++)
					planets[j].state=0;
					planets[i].state=1;
					}
			if (event.type == Event::MouseButtonPressed)
				if (event.key.code == Mouse::Right)
                   for (int i=0 ; i < N ; i++)
					if (event.mouseButton.x > planets[i].x && event.mouseButton.x < (planets[i].x + 200) && event.mouseButton.y > planets[i].y && event.mouseButton.y < (planets[i].y + 200) )
				    	if(planets[i].state==1)
							planets[i].state=0;
				window.clear();
				window.draw(fn_sprite);
				for (int i=0 ; i < N ; i++)
				{
					if(planets[i].state==0)
						window.draw(planets1_sprite[i]);
					else
						window.draw(planets2_sprite[i]);   
				}
				window.display();
	}
}
int main()
{
	float timescore=0;
	int N=4;//////////////////////для изменение количества планет менять циферку здесь
	struct planet  planets[4];///////////////////  и здесь (кроме того необходимо заполнить поля структуры)
	begining(planets);
	add_planets(planets,&timescore,N);
	cout << timescore <<endl;
}
