#include <SFML/Graphics.hpp>
#include <iostream>
#include <math.h>
using namespace sf;
using namespace std;
struct planet
{
	int name,x,y,ships,state,belong,type;
};
void begining(struct planet *planets)
{   
	///первая///
	planets[0].name=0;
	planets[0].state=0;
	planets[0].ships=5;
	planets[0].x=100;
	planets[0].y=400;
	planets[0].belong=1;// Пренадлежность к игроку(1-синий,2-красный,0-свободна)
	planets[0].type=1;//Один из трех типов планет(различия только визульные)
	///вторая///
	planets[1].name=1;
	planets[1].state=0;
	planets[1].ships=0;
	planets[1].x=700;
	planets[1].y=100;
	planets[1].belong=0;
	planets[1].type=2;
	///третья///
	planets[2].name=2;
	planets[2].state=0;
	planets[2].ships=0;
	planets[2].x=1000;
	planets[2].y=450;
	planets[2].belong=2;
	planets[2].type=3;
}
void add_planets(struct planet  *planets,int N)
{
	RenderWindow window(VideoMode(1280,720),"1.0");  
	////////фон//////////////////////////////

	Image fn; //создаем объект Image (изображение)
	fn.loadFromFile("images\\fn.jpg");//загружаем в него файл

	Texture fn_texture;//создаем объект Texture (текстура)
	fn_texture.loadFromImage(fn);//передаем в него объект Image (изображения)

	Sprite fn_sprite;//создаем объект Sprite(спрайт)
	fn_sprite.setTexture(fn_texture);//передаём в него объект Texture (текстуры)
	fn_sprite.setPosition(0, 0);//задаем начальные координаты появления спрайта
	
	Image _planets; 
	_planets.loadFromFile("images\\planets.jpg");
	_planets.createMaskFromColor(Color(0, 0, 0));
	Texture planets_texture;
	planets_texture.loadFromImage(_planets);
	Sprite planets1_sprite[3];
	Sprite planets2_sprite[3];
	for(int i=0 ; i < N ; i++)
	{
		planets1_sprite[i].setTexture(planets_texture);
		planets1_sprite[i].setPosition(planets[i].x, planets[i].y);
		planets2_sprite[i].setTexture(planets_texture);
		planets2_sprite[i].setPosition(planets[i].x, planets[i].y);
		int y1 = (planets[i].type-1)*200, y2=y1+600;
		planets1_sprite[i].setTextureRect(IntRect(0,y1,200,200));
		planets2_sprite[i].setTextureRect(IntRect(0,y2,200,200));
		if(planets[i].belong==1)
		{
			planets1_sprite[i].setColor(Color::Cyan);
			planets2_sprite[i].setColor(Color::Cyan);
		}
		if(planets[i].belong==2)
		{
			planets1_sprite[i].setColor(Color::Red);
			planets2_sprite[i].setColor(Color::Red);
		}
	}
	Clock clock;
	float timescore=0;
	while (window.isOpen())
	{
		float time = clock.getElapsedTime().asMicroseconds(); //дать прошедшее время в микросекундах
		clock.restart(); //перезагружает время
		time = time/1000; //скорость игры
		Event event;
		while (window.pollEvent(event))
		{
			if (event.type == sf::Event::Closed)
				window.close();
		}
		timescore=timescore+time;
		if(timescore > 250)  
			for (int i=0 ; i < N ; i++)
			{
				int y1 = (planets[i].type-1)*200, y2=y1+600;
				planets1_sprite[i].setTextureRect(IntRect(0,y1,200,200));
				planets2_sprite[i].setTextureRect(IntRect(0,y2,200,200));
			}
		if(timescore > 500)  
			for (int i=0 ; i < N ; i++)
			{
				int y1 = (planets[i].type-1)*200, y2=y1+600;
				planets1_sprite[i].setTextureRect(IntRect(200,y1,200,200));
				planets2_sprite[i].setTextureRect(IntRect(200,y2,200,200));
			}
		if(timescore > 750)  
			for (int i=0 ; i < N ; i++)
			{
				int y1 = (planets[i].type-1)*200, y2=y1+600;
				planets1_sprite[i].setTextureRect(IntRect(400,y1,200,200));
				planets2_sprite[i].setTextureRect(IntRect(400,y2,200,200));
			}	
		if(timescore > 1000)  
		{
			for (int i=0 ; i < N ; i++)
			{
				int y1 = (planets[i].type-1)*200, y2=y1+600;
				planets1_sprite[i].setTextureRect(IntRect(600,y1,200,200));
				planets2_sprite[i].setTextureRect(IntRect(600,y2,200,200));
			}
			timescore=0;
		} 
		if (event.type == Event::MouseButtonPressed)
			if (event.key.code == Mouse::Left)
				for (int i=0 ; i < N ; i++)
					if (event.mouseButton.x > planets[i].x && event.mouseButton.x < (planets[i].x + 200) && event.mouseButton.y > planets[i].y && event.mouseButton.y < (planets[i].y + 200) )
					{
                    for(int j=0; j < N;j++)
					planets[j].state=0;
					planets[i].state=1;
					}
			if (event.type == Event::MouseButtonPressed)
				if (event.key.code == Mouse::Right)
                   for (int i=0 ; i < N ; i++)
					if (event.mouseButton.x > planets[i].x && event.mouseButton.x < (planets[i].x + 200) && event.mouseButton.y > planets[i].y && event.mouseButton.y < (planets[i].y + 200) )
				    	if(planets[i].state==1)
							planets[i].state=0;
				window.clear();
				window.draw(fn_sprite);
				for (int i=0 ; i < N ; i++)
				{
					if(planets[i].state==0)
						window.draw(planets1_sprite[i]);
					else
						window.draw(planets2_sprite[i]);   
				}
				window.display();
	}
}
int main()
{
	int N=3;//////////////////////для изменение количества планет менять циферку здесь
	struct planet  planets[3];///////////////////  и здесь (кроме того необходимо заполнить поля структуры)
	begining(planets);
	add_planets(planets,N);
}
